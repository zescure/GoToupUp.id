<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>RazozBill Trade â€” Perdagangan Modern (Opsi) + Untung Takterbatas</title>
<style>
  :root{
    --bg:#0f1720; --panel:#0b1220; --muted:#9199a6; --accent:#2dd4bf; --green:#22c55e; --red:#fb7185;
    --card:#07101a; --glass: rgba(255,255,255,0.03);
  }
  *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;color:inherit}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#07121a 0%, #071628 100%);color:#e6eef6;overflow-x:hidden;-webkit-font-smoothing:antialiased}
  .topbar{display:flex;justify-content:space-between;align-items:center;padding:12px 16px;background:transparent;gap:12px;max-width:1200px;margin:0 auto;}
  .left-top{display:flex;align-items:center;gap:12px;min-width:0}
  .badge-live{background:#064e3b;color:var(--accent);padding:6px 10px;border-radius:8px;font-weight:700;display:flex;align-items:center;gap:8px;white-space:nowrap; cursor:pointer}
  .badge-live.demo{background:#334155;color:#fff;}
  .balance-pill{background:var(--panel);padding:8px 12px;border-radius:10px;font-weight:700;display:flex;gap:8px;align-items:center;white-space:nowrap}
  .deposit-btn{background:linear-gradient(90deg,#10b981,#059669);border:none;padding:10px 14px;border-radius:10px;color:#fff;font-weight:700;cursor:pointer;white-space:nowrap}
  .container{max-width:1200px;margin:12px auto;padding:12px;display:grid;grid-template-columns: 1fr 360px;gap:12px;width:100%;}
  .main-card{background:var(--card);border-radius:12px;padding:12px;box-shadow:0 6px 24px rgba(2,6,23,0.6);min-height:420px;overflow:hidden;}
  .side-card{background:var(--card);border-radius:12px;padding:12px;box-shadow:0 6px 24px rgba(2,6,23,0.6);min-height:420px;overflow:auto}
  .chart-top{display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:8px;flex-wrap:wrap}
  .pair-info{display:flex;gap:12px;align-items:center;min-width:0}
  .pair-title{font-weight:800;font-size:18px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .payout-pill{background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:8px;font-weight:700;color:#fff;white-space:nowrap}
  canvas#chartCanvas{width:100%;display:block;border-radius:8px;background:linear-gradient(180deg,#07101a,#081627);min-height:220px}
  .chart-footer{display:flex;justify-content:space-between;align-items:center;margin-top:8px;gap:8px;flex-wrap:wrap}
  .time-select{background:var(--glass);border:1px solid rgba(255,255,255,0.04);padding:6px;border-radius:8px;color:var(--muted);min-width:80px}
  .big-controls{display:flex;gap:12px;align-items:flex-start;margin-top:12px;flex-wrap:wrap}
  .big-left{flex:1;display:flex;flex-direction:column;gap:8px;min-width:220px}
  .big-right{flex-basis:320px;display:flex;flex-direction:column;gap:8px;transition:transform 220ms ease, box-shadow 220ms ease;}
  .input-box{background:#06101a;border:1px solid rgba(255,255,255,0.03);padding:10px;border-radius:8px;color:var(--muted);width:100%}
  .price-row{display:flex;justify-content:space-between;align-items:center;}
  .large-buttons{display:flex;gap:12px;}
  .btn-down{flex:1;padding:14px;border-radius:10px;background:linear-gradient(180deg,#ff7b7b,#ff6b6b);border:none;color:#fff;font-weight:800;font-size:18px;cursor:pointer;min-width:120px}
  .btn-up{flex:1;padding:14px;border-radius:10px;background:linear-gradient(180deg,#22c55e,#16a34a);border:none;color:#05201a;font-weight:800;font-size:18px;cursor:pointer;min-width:120px}
  .muted-small{color:var(--muted);font-size:13px;white-space:nowrap}
  .tabs{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
  .tab{padding:8px 12px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.03);cursor:pointer;color:var(--muted);}
  .tab.active{background:linear-gradient(90deg,#0f1724,#06202a);border:1px solid rgba(255,255,255,0.06);color:#fff;}
  .history-list{margin-top:10px;max-height:220px;overflow:auto;padding-right:6px}
  .history-item{display:flex;justify-content:space-between;padding:8px;border-bottom:1px solid rgba(255,255,255,0.02);font-size:13px}
  .status-badge{padding:4px 8px;border-radius:6px;font-weight:700;font-size:12px}
  .status-pending{background:rgba(255,193,7,0.12);color:#ffb020}
  .status-confirmed{background:rgba(34,197,94,0.12);color:var(--green)}
  .status-rejected{background:rgba(239,68,68,0.08);color:var(--red)}
  .admin-controls{margin-top:12px;padding:8px;background:rgba(255,255,255,0.02);border-radius:8px;}
  .market-edit{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}
  .market-edit input{padding:6px;border-radius:6px;background:#06101a;border:1px solid rgba(255,255,255,0.03);color:#fff}
  .save-btn{padding:6px 10px;border-radius:8px;background:#0ea5a4;border:none;color:#012;cursor:pointer}

  /* open trade styling: border + countdown etc */
  .open-trade {
    border: 1px solid rgba(45,212,191,0.12);
    background: linear-gradient(180deg, rgba(45,212,191,0.02), rgba(45,212,191,0.01));
    border-radius:8px;
    padding:10px;
    margin-bottom:8px;
    display:flex;
    justify-content:space-between;
    gap:12px;
    align-items:center;
  }
  .open-trade .left{min-width:0}
  .open-trade .meta{font-size:13px;color:var(--muted)}
  .open-trade .prices{display:flex;flex-direction:column;gap:4px;font-weight:700;text-align:right}
  .countdown{font-weight:800;color:#fff;background:rgba(0,0,0,0.2);padding:6px 10px;border-radius:8px}
  .entry-exit{font-size:13px;color:var(--muted)}
  .trade-closed { opacity: 0.6; border-style: dashed; }

  @media (max-width:1000px){
    .container{grid-template-columns:1fr;}
    .big-right{flex-basis:100%}
    .side-card{order:2}
    .main-card{order:1}
    .pair-title{font-size:16px}
  }
  @media (max-width:520px){
    .btn-up,.btn-down{font-size:16px;padding:12px}
    .history-item{font-size:12px;padding:6px}
  }

  .chart-wrap{position:relative}
  .price-marker{
    position:absolute;
    right:10px;
    top:10px;
    background:rgba(0,0,0,0.45);
    padding:6px 10px;border-radius:8px;font-weight:800;border:1px solid rgba(255,255,255,0.04);
    backdrop-filter: blur(4px)
  }
  .market-locked { color: #ffb020; font-weight:800; margin-left:8px; font-size:13px; }
</style>
</head>
<body>
  <div class="topbar">
    <div class="left-top">
      <div class="badge-live" id="badgeLive">LIVE</div>
      <div style="color:var(--muted);font-size:13px">UTC+7 â€¢ <span id="clock">--:--:--</span></div>
      <span id="balanceTop" style="display:none">0.00</span>
    </div>
    <div style="display:flex;gap:12px;align-items:center">
      <button class="deposit-btn" id="openDeposit">+</button>
      <div class="balance-pill">Saldo: <span id="balance" style="margin-left:8px">0.00</span></div>
    </div>
  </div>

  <div class="container">
    <div class="main-card">
      <div class="chart-top">
        <div class="pair-info">
          <div style="width:48px;height:48px;border-radius:8px;background:linear-gradient(180deg,#0b1220,#06101a);display:flex;align-items:center;justify-content:center;font-weight:800">ðŸ”·</div>
          <div style="min-width:0">
            <div class="pair-title" id="pairTitle">Memuat market...</div>
            <div class="muted-small" id="pairSub">â€” <span id="lockedLabel"></span></div>
          </div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <div class="payout-pill" id="payoutLabel">â€”%</div>
          <select id="symbolSelectTop" class="time-select"></select>
          <div style="width:120px;text-align:right;">
            <div style="font-size:12px;color:var(--muted)">Harga sekarang</div>
            <div style="font-weight:800;font-size:18px" id="currentPriceLarge">-</div>
          </div>
        </div>
      </div>

      <div class="chart-wrap">
        <canvas id="chartCanvas"></canvas>
        <div class="price-marker" id="priceMarker">â€”</div>
      </div>

      <div class="chart-footer">
        <div style="display:flex;gap:8px;align-items:center;">
          <select id="tfSelect" class="time-select">
            <option value="1">Global</option>
            <option value="5">Asia</option>
            <option value="15">Eropa</option>
            <option value="60">Amerika</option>
          </select>
          <div class="muted-small">Durasi trade: <span id="currDur">60</span>s</div>
        </div>
        <div class="muted-small">perdagangan modern dan dapatkan keuntungan takterbatas</div>
      </div>

      <div class="big-controls">
        <div class="big-left">
          <div style="display:flex;gap:8px;flex-wrap:wrap;">
            <div style="flex:1;min-width:150px">
              <div class="muted-small">Waktu kedaluwarsa</div>
              <input id="durationInput" class="input-box" type="text" value="00:01:00">
            </div>
            <div style="width:180px;min-width:120px">
              <div class="muted-small">Nominal (Rp)</div>
              <input id="betAmount" class="input-box" type="number" min="14900" value="14000">
            </div>
          </div>

          <div style="display:flex;gap:12px;align-items:center;margin-top:10px;">
            <div class="muted-small">Pembayaran:</div>
            <div id="paymentLabel" style="font-weight:800">â€” Rp</div>
            <div style="margin-left:12px;color:var(--muted);font-size:13px" id="payoutInfo">Keuntungan â€”</div>
          </div>

          <div class="tabs">
            <div class="tab active" id="tabOpenTrades">Trade Terbuka</div>
            <div class="tab" id="tabTradeHistory">Trade History</div>
            <div class="tab" id="tabRequests">Withdraw</div>
          </div>

          <div class="history-list" id="listOpenTrades"></div>
          <div class="history-list" id="listTrades" style="display:none"></div>
          <div class="history-list" id="listRequests" style="display:none"></div>

        </div>

        <div class="big-right" id="bigRight">
          <div style="display:flex;flex-direction:column;gap:10px;">
            <div style="display:flex;gap:8px;align-items:center;">
              <button class="btn-down" id="btnDown">TURUN</button>
              <button class="btn-up" id="btnUp">NAIK</button>
            </div>

            <div style="background:transparent;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);">
              <div style="display:flex;justify-content:space-between;align-items:center;">
                <div style="font-weight:800">Ringkasan Transaksi</div>
                <div style="font-size:12px;color:var(--muted)">Minimal Rp 15.000</div>
              </div>
              <div style="margin-top:8px;display:flex;flex-direction:column;gap:6px">
                <div class="price-row"><div class="muted-small">Nominal Trade</div><div id="summaryBet">Rp 14,000</div></div>
                <div class="price-row"><div class="muted-small">Probabilitas / Payout</div><div id="summaryPayout">â€”%</div></div>
                <div class="price-row"><div class="muted-small">Potensi Keuntungan</div><div id="summaryPotential">â€” Rp</div></div>
                <div class="price-row"><div class="muted-small">Saldo Terakhir</div><div id="summaryBalance">Rp 0</div></div>
              </div>
            </div>

            <div style="background:transparent;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);">
              <div style="display:flex;justify-content:space-between;align-items:center;">
                <div style="font-weight:800">Deposit / Withdraw</div>
                <button id="openDeposit2" class="deposit-btn" style="padding:6px 10px;font-size:13px">Deposit</button>
              </div>
              <div style="margin-top:8px;color:var(--muted);font-size:13px">Ganti Ke Akun Demo Klik Pnel Hijau DiKiri Atas</div>
              <div style="margin-top:8px" id="miniRequests"></div>
            </div>

            <div id="adminInline" style="display:none;">
              <div class="admin-controls">
                <div style="font-weight:800">Admin â€” Edit Market</div>
                <div id="adminMarketsContainer"></div>
              </div>
            </div>

          </div>
        </div>
      </div>

    </div>

    <div class="side-card">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div style="font-weight:800">Akun</div>
        <div style="color:var(--muted)">UID: <span id="uidLabel">-</span></div>
      </div>

      <div style="background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;margin-bottom:12px;">
        <div style="font-size:13px;color:var(--muted)">Saldo Real</div>
        <div style="font-weight:800;font-size:20px;margin-top:6px">Rp <span id="balanceMain">0.00</span></div>
        <div style="margin-top:8px;color:var(--muted)">Riwayat deposit & withdraw </div>
      </div>

      <div style="font-weight:800;margin-bottom:8px">Deposit / Withdraw Requests</div>
      <div id="sideRequestsList" style="max-height:200px;overflow:auto"></div>

      <div style="margin-top:12px;font-weight:800">Trade History (Ringkas)</div>
      <div id="sideTradeList" style="max-height:200px;overflow:auto;margin-top:8px"></div>

      <div id="adminPanel" style="margin-top:12px;display:none;">
        <h3 style="margin:0 0 8px 0">Admin Panel â€” Requests</h3>
        <div id="requestsList"></div>
      </div>

    </div>
  </div>

  <!-- Deposit Modal -->
  <div id="depositModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.6);z-index:2000;align-items:center;justify-content:center;">
    <div style="background:#07121a;padding:16px;border-radius:12px;width:420px;color:#e6eef6;">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="font-weight:800">Deposit Saldo</div>
        <button id="depositClose" style="background:none;border:none;color:var(--muted);cursor:pointer">âœ•</button>
      </div>
      <div style="margin-top:10px">
        <label class="muted-small">Nominal (Rp)</label>
        <input id="depositAmount" type="number" class="input-box" value="20000" min="1000">
        <label class="muted-small">No. Rekening Pengirim</label>
        <input id="depositAccount" class="input-box" type="text" placeholder="1234567890">
        <label class="muted-small">Metode</label>
        <select id="depositMethod" class="input-box"><option value="Dana">QRIS Dana</option></select>
        <div style="margin-top:8px;display:flex;gap:8px;">
          <button id="depositPay" class="deposit-btn" style="flex:1">Generate QR & Request</button>
          <button id="depositCancel" style="background:#334155;border:none;padding:10px;border-radius:8px;color:#fff;cursor:pointer">Batal</button>
        </div>
        <div id="depositQRWrap" style="margin-top:12px;display:none;">
          <div id="qrcodeDyn"></div>
          <pre id="finalPayload" style="background:#07121a;padding:8px;border-radius:8px;color:var(--muted);overflow:auto;"></pre>
          <button id="markPaidBtn" style="margin-top:8px;padding:8px;border-radius:8px;background:#0ea5a4;border:none;color:#012;cursor:pointer">Sudah Bayar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- libs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

<script>
/* ================= CONFIG ================= */
const firebaseConfig = {
  apiKey: "AIzaSyDVUEZ3ZVmH4ld7LVnEq_L368wEJpEs-l8",
  authDomain: "zeepaylater-93a94.firebaseapp.com",
  projectId: "zeepaylater-93a94",
  storageBucket: "zeepaylater-93a94.appspot.com",
  messagingSenderId: "358065954807",
  appId: "1:358065954807:web:66619211fea82a4b2518f2"
};
const ADMIN_UID = 'viCOsJo4wHVFmhtpmMx1Wd4sDF52';
const DEPOSIT_URL = 'https://zestore.netlify.app/depositop1';
/* ========================================== */

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();

/* ====== GLOBAL STATE & UI EL ====== */
let currentUser = null;
let isAdmin = false;
let markets = {};            // will be filled from CoinGecko top-10
let currentMarketId = null;

/* Chart timing & history */
const TICK_INTERVAL = 2500;    // inner sampling for smoothness
const MIN_TICK_MS = 60_000;    // 1 minute tick for printed points
const HISTORY_MINUTES = 18;    // how many minutes to keep (adjustable)

const pairTitle = document.getElementById('pairTitle');
const pairSub = document.getElementById('pairSub');
const lockedLabel = document.getElementById('lockedLabel');
const payoutLabel = document.getElementById('payoutLabel');
const currentPriceLarge = document.getElementById('currentPriceLarge');
const priceMarker = document.getElementById('priceMarker');
const symbolSelectTop = document.getElementById('symbolSelectTop');
const summaryBet = document.getElementById('summaryBet');
const summaryPayout = document.getElementById('summaryPayout');
const summaryPotential = document.getElementById('summaryPotential');
const summaryBalance = document.getElementById('summaryBalance');
const payoutInfo = document.getElementById('payoutInfo');

const tabOpenTrades = document.getElementById('tabOpenTrades');
const tabTradeHistory = document.getElementById('tabTradeHistory');
const tabRequests = document.getElementById('tabRequests');
const listOpenTrades = document.getElementById('listOpenTrades');
const listTrades = document.getElementById('listTrades');
const listRequests = document.getElementById('listRequests');

const sideRequestsList = document.getElementById('sideRequestsList');
const sideTradeList = document.getElementById('sideTradeList');
const requestsList = document.getElementById('requestsList');
const adminPanel = document.getElementById('adminPanel');
const adminMarketsContainer = document.getElementById('adminMarketsContainer');
const adminInline = document.getElementById('adminInline');

const balanceEl = document.getElementById('balance');
const balanceTop = document.getElementById('balanceTop'); // hidden in DOM for compatibility
const balanceMain = document.getElementById('balanceMain');
const uidLabel = document.getElementById('uidLabel');

const btnUp = document.getElementById('btnUp');
const btnDown = document.getElementById('btnDown');
const betAmountInput = document.getElementById('betAmount');
const durationInput = document.getElementById('durationInput');
const paymentLabel = document.getElementById('paymentLabel');

const openDeposit = document.getElementById('openDeposit');
const openDeposit2 = document.getElementById('openDeposit2');
const depositModal = document.getElementById('depositModal');
const depositClose = document.getElementById('depositClose');
const depositCancel = document.getElementById('depositCancel');
const depositPay = document.getElementById('depositPay');
const depositAmount = document.getElementById('depositAmount');
const depositAccount = document.getElementById('depositAccount');
const depositMethod = document.getElementById('depositMethod');
const depositQRWrap = document.getElementById('depositQRWrap');
const qrcodeDyn = document.getElementById('qrcodeDyn');
const finalPayloadEl = document.getElementById('finalPayload');
const markPaidBtn = document.getElementById('markPaidBtn');
const bigRightEl = document.getElementById('bigRight');
const badgeLive = document.getElementById('badgeLive');

const DEFAULT_BASE_PAYLOAD = "00020101021126610014COM.GO-JEK.WWW01189360091433055874630210G3055874630303UMI51440014ID.CO.QRIS.WWW0215ID10254231099470303UMI5204481453033602ID5925ZkgamingstoreGoTo, Toko H6007TANGSEL61051522062070703A0163040657";

/* ===== CoinGecko integration settings ===== */
const COINGECKO_BASE = 'https://api.coingecko.com/api/v3';
let CG_VS_CURRENCY = 'idr'; // <-- ubah jadi 'idr' kalau mau tampil Rupiah
const PRICE_POLL_INTERVAL = 5000; // 5s between polls (batched)
let lastPriceMap = {}; // cgId -> { price, ts, change24h }

/* ===== deterministic fallback helpers ===== */
function hashStringToInt(s){
  let h = 2166136261 >>> 0;
  for (let i=0;i<s.length;i++){
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619) >>> 0;
  }
  return h >>> 0;
}
function randDeterministic(seedInt, timeBucket){
  const x = Math.sin((seedInt ^ timeBucket) * 0.00000137) * 100000;
  return x - Math.floor(x);
}
function deterministicPrice(marketId, timestampMs){
  const market = markets[marketId];
  const base = (market && typeof market.price !== 'undefined') ? Number(market.price) : 100;
  const interval = TICK_INTERVAL;
  const bucket = Math.floor(timestampMs / interval);
  const seedInt = market && market.seed ? Number(market.seed) : hashStringToInt(marketId || 'DEFAULT');
  const r = randDeterministic(seedInt, bucket);
  const volFraction = (market && market.volatilityFraction) ? Number(market.volatilityFraction) : 0.002;
  const amplitude = Math.max(0.0001, base * volFraction);
  const sine = Math.sin((bucket % 3600) / 180 * Math.PI);
  const noise = (r - 0.5) * 2;
  const offset = amplitude * (0.6 * sine + 0.4 * noise);
  return Math.max(0.0000001, base + offset);
}

/* ===== Chart setup ===== */
const chartCanvas = document.getElementById('chartCanvas');
const ctx = chartCanvas.getContext('2d');
let chartData = []; // per-minute anchor points
let animationId = null;
let lastMinuteAppended = null;
let lastPrice = 1;

/* responsive canvas sizing */
function resizeCanvas(){
  const targetHeight = Math.min(window.innerHeight * 0.45, 420);
  chartCanvas.style.height = targetHeight + 'px';
  const rect = chartCanvas.getBoundingClientRect();
  chartCanvas.width = Math.max(300, Math.floor(rect.width * devicePixelRatio));
  chartCanvas.height = Math.max(150, Math.floor(rect.height * devicePixelRatio));
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  drawChart();
}
window.addEventListener('resize', ()=>{ try{ resizeCanvas(); }catch(e){} });

/* ===== CoinGecko helpers: fetch top-10 markets & poll prices ===== */
async function fetchTop10CoinGeckoMarkets(){
  try{
    const url = `${COINGECKO_BASE}/coins/markets?vs_currency=${CG_VS_CURRENCY}&order=market_cap_desc&per_page=10&page=1&sparkline=false&price_change_percentage=24h`;
    const res = await fetch(url);
    if(!res.ok) throw new Error('cg top10 failed ' + res.status);
    const data = await res.json(); // array of coins
    // rebuild markets
    markets = {};
    data.forEach(coin=>{
      // key by SYMBOL/ID so it's readable
      const key = (coin.symbol||'').toUpperCase() + '/' + coin.id;
      markets[key] = {
        cgId: coin.id,
        symbol: (coin.symbol||'').toUpperCase(),
        name: coin.name || coin.id,
        price: coin.current_price || 0,
        volatilityFraction: 0.004, // default visual jitter
        payoutPercent: 70,
        locked: false
      };
    });
    // update UI select
    symbolSelectTop.innerHTML = '';
    Object.keys(markets).forEach(k=>{
      const m = markets[k];
      const opt = document.createElement('option');
      opt.value = k;
      opt.text = `${m.symbol} â€” ${m.name}`;
      symbolSelectTop.appendChild(opt);
    });
    if(Object.keys(markets).length){
      currentMarketId = symbolSelectTop.value || Object.keys(markets)[0];
    }
    updateMarketUI();
    generateInitialChartData();
    startChartAnimation();
  }catch(e){
    console.error('fetchTop10CoinGeckoMarkets err', e);
    // fallback: leave markets empty, can still run deterministic markets
  }
}

let cgPollTimer = null;
async function pollCoinGeckoPrices(){
  if(cgPollTimer) clearTimeout(cgPollTimer);
  const ids = Object.values(markets).map(m => m.cgId).filter(Boolean);
  if(ids.length === 0){
    cgPollTimer = setTimeout(pollCoinGeckoPrices, PRICE_POLL_INTERVAL);
    return;
  }
  const uniq = Array.from(new Set(ids));
  const batch = uniq.join(',');
  try{
    const url = `${COINGECKO_BASE}/simple/price?ids=${encodeURIComponent(batch)}&vs_currencies=${CG_VS_CURRENCY}&include_24hr_change=true`;
    const res = await fetch(url);
    if(!res.ok) throw new Error('price fetch err ' + res.status);
    const data = await res.json(); // { id: { usd: 123, usd_24h_change: x }, ... }
    Object.keys(data).forEach(id=>{
      lastPriceMap[id] = {
        price: Number(data[id][CG_VS_CURRENCY]) || 0,
        change24h: Number(data[id][CG_VS_CURRENCY + '_24h_change'] || data[id].usd_24h_change || 0),
        ts: Date.now()
      };
    });
    localStorage.setItem('cg_price_cache_v1', JSON.stringify({ t: Date.now(), data: lastPriceMap }));
  }catch(e){
    console.warn('pollCoinGeckoPrices err', e);
    try{
      const raw = localStorage.getItem('cg_price_cache_v1');
      if(raw){
        const parsed = JSON.parse(raw);
        if(parsed.data) lastPriceMap = parsed.data;
      }
    }catch(er){}
  } finally {
    cgPollTimer = setTimeout(pollCoinGeckoPrices, PRICE_POLL_INTERVAL);
  }
}

function getMarketLivePrice(marketId){
  const m = markets[marketId];
  if(m && m.cgId && lastPriceMap[m.cgId] && typeof lastPriceMap[m.cgId].price !== 'undefined'){
    return lastPriceMap[m.cgId].price;
  }
  // fallback to stored price from initial fetch
  if(m && typeof m.price !== 'undefined') return m.price;
  // final fallback deterministic
  return deterministicPrice(marketId, Date.now());
}

async function fetchLatestPriceForMarket(marketId){
  const m = markets[marketId];
  if(m && m.cgId){
    try{
      const url = `${COINGECKO_BASE}/simple/price?ids=${encodeURIComponent(m.cgId)}&vs_currencies=${CG_VS_CURRENCY}`;
      const res = await fetch(url);
      if(res.ok){
        const j = await res.json();
        const price = Number(j[m.cgId] && j[m.cgId][CG_VS_CURRENCY] ? j[m.cgId][CG_VS_CURRENCY] : NaN);
        if(!isNaN(price)){
          lastPriceMap[m.cgId] = { price, ts: Date.now() };
          localStorage.setItem('cg_price_cache_v1', JSON.stringify({ t: Date.now(), data: lastPriceMap }));
          return price;
        }
      }
    }catch(e){ console.warn('fetchLatestPriceForMarket err', e); }
  }
  return deterministicPrice(marketId, Date.now());
}

/* ===== generate per-minute history anchors ===== */
function generateInitialChartData(){
  chartData = [];
  const now = Date.now();
  const marketId = currentMarketId || Object.keys(markets)[0] || 'DEFAULT/PRICE';
  const currentMinuteStart = Math.floor(now / MIN_TICK_MS) * MIN_TICK_MS;
  const m = markets[marketId];
  let seedPrice = null;
  if(m && m.cgId && lastPriceMap[m.cgId] && (Date.now() - lastPriceMap[m.cgId].ts < 60_000 * 60)){
    seedPrice = lastPriceMap[m.cgId].price;
  } else if(m && typeof m.price !== 'undefined'){
    seedPrice = m.price;
  }
  for (let i = HISTORY_MINUTES - 1; i >= 0; i--) {
    const ts = currentMinuteStart - (i * MIN_TICK_MS);
    let price;
    if(seedPrice !== null){
      const jitter = (Math.sin((i+1) * 0.7) * 0.003 + (Math.random()-0.5)*0.002) * seedPrice;
      price = Math.max(0.0000001, seedPrice + jitter);
    } else {
      price = deterministicPrice(marketId, ts);
    }
    chartData.push({ timestamp: ts, price });
  }
  lastMinuteAppended = Math.floor(chartData[chartData.length - 1].timestamp / MIN_TICK_MS);
  lastPrice = chartData[chartData.length - 1].price;
  resizeCanvas();
  drawChart();
  updateDisplayedPrice();
}

/* draw chart using minute anchors + live interpolated point */
function drawChart(){
  if(!ctx) return;
  const canvas = chartCanvas;
  const width = canvas.width / devicePixelRatio;
  const height = canvas.height / devicePixelRatio;
  ctx.clearRect(0,0,width,height);
  if(!chartData.length) return;

  ctx.fillStyle = '#07121a';
  ctx.fillRect(0,0,width,height);

  const padding = 12;
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.lineWidth = 1;
  const gridCount = 5;
  for(let i=0;i<gridCount;i++){
    ctx.beginPath(); ctx.moveTo(0,(height/gridCount)*i); ctx.lineTo(width,(height/gridCount)*i); ctx.stroke();
  }

  const now = Date.now();
  const marketId = currentMarketId || Object.keys(markets)[0] || 'DEFAULT/PRICE';
  const livePrice = getMarketLivePrice(marketId);

  const displayData = chartData.slice();
  displayData.push({ timestamp: now, price: livePrice });

  const minTs = displayData[0].timestamp;
  const maxTs = displayData[displayData.length-1].timestamp;
  const tsRange = Math.max(1, maxTs - minTs);

  ctx.font = '11px Inter, Arial, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.fillStyle = 'rgba(255,255,255,0.36)';
  const startMinute = Math.floor(minTs / MIN_TICK_MS) * MIN_TICK_MS;
  for(let t = startMinute; t <= maxTs; t += MIN_TICK_MS){
    const xTick = padding + ((t - minTs) / tsRange) * (width - padding*2);
    ctx.beginPath();
    ctx.moveTo(xTick, padding);
    ctx.lineTo(xTick, height - padding);
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.stroke();
    try {
      const d = new Date(t);
      const label = d.toLocaleTimeString();
      ctx.fillText(label, xTick, height - 4);
    } catch(e){}
  }

  const prices = displayData.map(d=>d.price);
  const minP = Math.min(...prices), maxP = Math.max(...prices);
  const range = (maxP - minP) || (Math.abs(maxP)*0.001) || 1;

  ctx.beginPath();
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#2dd4bf';
  for(let i=0;i<displayData.length;i++){
    const d = displayData[i];
    const x = padding + ((d.timestamp - minTs) / tsRange) * (width - padding*2);
    const normalized = (d.price - minP)/range;
    const y = height - (normalized * (height - padding*2)) - padding;
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  const last = displayData[displayData.length-1];
  const lastX = padding + ((last.timestamp - minTs) / tsRange) * (width - padding*2);
  const lastY = height - ((last.price - minP)/range)*(height - padding*2) - padding;
  ctx.fillStyle = '#0f1724';
  ctx.beginPath(); ctx.arc(lastX, lastY, 6, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(lastX, lastY, 10, 0, Math.PI*2); ctx.strokeStyle = 'rgba(45,212,191,0.12)'; ctx.lineWidth=2; ctx.stroke();
}

/* animation */
function startChartAnimation(){
  if(animationId) cancelAnimationFrame(animationId);
  let prevPrice = lastPrice;
  function step(){
    const now = Date.now();
    const marketId = currentMarketId || Object.keys(markets)[0] || 'DEFAULT/PRICE';
    const currentMinuteBucket = Math.floor(now / MIN_TICK_MS);
    if(lastMinuteAppended === null && chartData.length) lastMinuteAppended = Math.floor(chartData[chartData.length-1].timestamp / MIN_TICK_MS);
    if(lastMinuteAppended === null) lastMinuteAppended = currentMinuteBucket - 1;

    while(lastMinuteAppended < currentMinuteBucket){
      lastMinuteAppended++;
      const minuteTs = lastMinuteAppended * MIN_TICK_MS;
      let minutePrice;
      const m = markets[marketId];
      if(m && m.cgId && lastPriceMap[m.cgId]) minutePrice = lastPriceMap[m.cgId].price * (1 + (Math.random()-0.5)*0.002);
      else minutePrice = deterministicPrice(marketId, minuteTs);
      chartData.push({ timestamp: minuteTs, price: minutePrice });
      if(chartData.length > HISTORY_MINUTES) chartData.shift();
      lastPrice = minutePrice;
    }

    drawChart();
    updateDisplayedPrice();

    try{
      const cur = getMarketLivePrice(currentMarketId || Object.keys(markets)[0]);
      const delta = cur - prevPrice;
      const move = delta > 0 ? -6 : (delta < 0 ? 6 : 0);
      bigRightEl.style.transform = `translateY(${move}px)`;
      if(delta > 0) bigRightEl.style.boxShadow = '0 8px 24px rgba(34,197,94,0.06)';
      else if(delta < 0) bigRightEl.style.boxShadow = '0 8px 24px rgba(239,68,68,0.04)';
      else bigRightEl.style.boxShadow = 'none';
      prevPrice = cur;
    }catch(e){}
    animationId = requestAnimationFrame(step);
  }
  step();
}

function updateDisplayedPrice(){
  const cur = getMarketLivePrice(currentMarketId || Object.keys(markets)[0]);
  if(cur >= 0.01) currentPriceLarge.textContent = Number(cur).toFixed(2);
  else currentPriceLarge.textContent = Number(cur).toFixed(6);
  priceMarker.textContent = currentPriceLarge.textContent;
}

/* ===== markets UI update (now from CoinGecko top-10) ===== */
function updateMarketUI(){
  const m = markets[currentMarketId];
  if(!m){
    pairTitle.textContent = currentMarketId || 'â€”';
    pairSub.textContent = '';
    payoutLabel.textContent = '-%';
    summaryPayout.textContent = '-%';
    summaryPotential.textContent = '- Rp';
    lockedLabel.textContent = '';
    return;
  }
  pairTitle.textContent = `${m.symbol || currentMarketId}`;
  pairSub.textContent = `${m.name || ''} â€¢ ${currentMarketId}` + (m.cgId ? ` â€¢ cg:${m.cgId}` : '');
  payoutLabel.textContent = (m.payoutPercent || 70) + '%';
  summaryPayout.textContent = (m.payoutPercent || 70) + '%';
  payoutInfo.textContent = `untung ${m.payoutPercent || 70}% dari taruhan`;
  lockedLabel.textContent = m.locked ? 'MARKET TUTUP' : '';
  if(m.locked){ lockedLabel.className = 'market-locked'; } else { lockedLabel.className = ''; }
  updateSummary();
}

/* ===== account mode (Live / Demo) ===== */
let accountMode = 'live';
let demoBalance = 100000;

function getActiveBalance(){ return accountMode === 'demo' ? demoBalance : balance; }
function setActiveBalance(v){ if(accountMode === 'demo') { demoBalance = Number(v); } else { balance = Number(v); } updateBalanceDisplays(); }
function updateBalanceDisplays(){
  const val = getActiveBalance();
  balanceEl.textContent = Number(val).toFixed(2);
  if(balanceTop) balanceTop.textContent = Number(val).toFixed(2);
  balanceMain.textContent = Number(val).toFixed(2);
  summaryBalance.innerText = `Rp ${Number(val).toLocaleString('id-ID')}`;
  if(accountMode === 'demo'){
    openDeposit.textContent = 'Refresh';
    openDeposit.title = 'Refresh saldo demo';
    openDeposit2.textContent = 'Refresh';
    badgeLive.classList.add('demo');
    badgeLive.textContent = 'DEMO';
  } else {
    openDeposit.textContent = 'Deposit';
    openDeposit.title = 'Deposit ke akun Live';
    openDeposit2.textContent = 'Deposit';
    badgeLive.classList.remove('demo');
    badgeLive.textContent = 'LIVE';
  }
}

/* badge click toggles account mode */
badgeLive.addEventListener('click', ()=>{
  accountMode = (accountMode === 'live') ? 'demo' : 'live';
  updateBalanceDisplays();
  if(accountMode === 'demo') loadDemoOpenTrades();
  else renderMiniRequests();
  try{ alert('Mode akun: ' + accountMode.toUpperCase()); }catch(e){}
});

/* ===== summary & UI helpers ===== */
function updateSummary(){
  const bet = Number(betAmountInput.value || 0);
  summaryBet.innerText = `Rp ${Number(bet).toLocaleString('id-ID')}`;
  summaryBalance.innerText = `Rp ${Number(getActiveBalance()).toLocaleString('id-ID')}`;
  const m = markets[currentMarketId];
  const payout = (m && m.payoutPercent) ? Number(m.payoutPercent) : 70;
  summaryPayout.innerText = `${payout}%`;
  const potential = Math.round(bet * (payout/100) + bet);
  summaryPotential.innerText = `Rp ${potential.toLocaleString('id-ID')}`;
  paymentLabel.innerText = `â€” Rp ${potential.toLocaleString('id-ID')}`;
}

/* ===== helpers ===== */
function formatSecondsMMSS(s){
  if(typeof s !== 'number' || s < 0) s = 0;
  const mm = Math.floor(s/60); const ss = s % 60;
  return String(mm).padStart(2,'0') + ':' + String(ss).padStart(2,'0');
}
function parseDurationToSeconds(s){
  const parts = s.split(':').map(p=>Number(p));
  if(parts.length===3) return parts[0]*3600 + parts[1]*60 + parts[2];
  if(parts.length===2) return parts[0]*60 + parts[1];
  return Number(s) || 60;
}

/* ===== persistence & timers for open trades ===== */
let openTrades = []; // memory
const demoTradeTimers = {};
const liveTradeTimers = {};

function saveDemoOpenTrades(){
  const demoList = openTrades.filter(t => t._mode === 'demo');
  localStorage.setItem('demoOpenTrades', JSON.stringify(demoList));
}
function loadDemoOpenTrades(){
  const raw = localStorage.getItem('demoOpenTrades');
  if(!raw) return;
  try{
    const arr = JSON.parse(raw);
    if(!Array.isArray(arr)) return;
    arr.forEach(tr=>{
      if(openTrades.find(x=>x.id === tr.id)) return;
      tr._mode = 'demo';
      openTrades.push(tr);
      addOpenTradeUI(tr);
      scheduleDemoResolution(tr);
    });
    updateSummary();
    updateBalanceDisplays();
  }catch(e){ console.error('load demo open trades err', e); }
}
function removeDemoOpenTradeById(id){
  openTrades = openTrades.filter(x=>!(x.id === id && x._mode === 'demo'));
  saveDemoOpenTrades();
}
function scheduleDemoResolution(tr){
  const now = Date.now();
  const remaining = Math.max(0, tr.expiryTs - now);
  if(demoTradeTimers[tr.id]) clearTimeout(demoTradeTimers[tr.id]);
  const to = setTimeout(()=>{
    try{ resolveDemoTrade(tr); }catch(e){ console.error(e); }
    delete demoTradeTimers[tr.id];
  }, remaining);
  demoTradeTimers[tr.id] = to;
}

/* Live openTrades persistence: subscribe to user's openTrades */
let userOpenTradesUnsub = null;
function subscribeUserOpenTrades(uid){
  if(userOpenTradesUnsub) userOpenTradesUnsub();
  const col = db.collection('users').doc(uid).collection('openTrades');
  userOpenTradesUnsub = col.onSnapshot(snap=>{
    snap.docChanges().forEach(change=>{
      const doc = change.doc;
      const data = doc.data();
      const id = doc.id;
      if(change.type === 'added' || change.type === 'modified'){
        const tr = { ...data, id: id, _mode: 'live' };
        if(!openTrades.find(x=>x.id === id)){
          openTrades.push(tr);
          addOpenTradeUI(tr);
          scheduleLiveResolution(tr);
        }
      } else if(change.type === 'removed'){
        if(liveTradeTimers[id]){ clearTimeout(liveTradeTimers[id]); delete liveTradeTimers[id]; }
        openTrades = openTrades.filter(x=>x.id !== id);
        removeOpenTradeUI(id);
      }
    });
  }, err=>console.error(err));
}
function scheduleLiveResolution(tr){
  const now = Date.now();
  const remaining = Math.max(0, tr.expiryTs - now);
  if(liveTradeTimers[tr.id]) clearTimeout(liveTradeTimers[tr.id]);
  const to = setTimeout(()=>{
    try{ resolveLiveTrade(tr.id); }catch(e){ console.error(e); }
    delete liveTradeTimers[tr.id];
  }, remaining);
  liveTradeTimers[tr.id] = to;
}

/* ===== open trade UI helpers ===== */
function createOpenTradeElement(tr){
  const wrapper = document.createElement('div');
  wrapper.className = 'open-trade';
  wrapper.id = 'open_' + tr.id;

  const entryFormatted = Number(tr.entryPrice).toFixed(2);
  const expectedExit = getMarketLivePrice(tr.market);
  const expectedExitFormatted = Number(expectedExit).toFixed(2);
  const remainingMs = Math.max(0, tr.expiryTs - Date.now());
  const remainingSec = Math.ceil(remainingMs / 1000);

  wrapper.innerHTML = `
    <div class="left">
      <div style="font-weight:800;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${tr.market} â€¢ ${tr.side}</div>
      <div class="meta entry-exit">Entry: <strong class="entryPrice">${entryFormatted}</strong> â€¢ Rata": <strong class="exitPrice">${expectedExitFormatted}</strong></div>
      <div class="meta">Investasi: Rp ${Number(tr.amount).toLocaleString()}</div>
    </div>
    <div style="display:flex;flex-direction:column;align-items:flex-end;gap:6px">
      <div class="countdown" data-expiry="${tr.expiryTs}">${formatSecondsMMSS(remainingSec)}</div>
      <div class="meta" style="color:var(--muted);font-size:12px">ID: ${tr.id}</div>
    </div>
  `;
  return wrapper;
}
function addOpenTradeUI(tr){
  if(document.getElementById('open_' + tr.id)) return;
  const el = createOpenTradeElement(tr);
  listOpenTrades.prepend(el);

  const countdownEl = el.querySelector('.countdown');
  const exitPriceEl = el.querySelector('.exitPrice');

  tr._uiInterval = setInterval(()=>{
    const now = Date.now();
    const remainingMs = Math.max(0, tr.expiryTs - now);
    const sec = Math.ceil(remainingMs/1000);
    countdownEl.textContent = formatSecondsMMSS(sec);
    const expectedExit = getMarketLivePrice(tr.market);
    exitPriceEl.textContent = (expectedExit >= 0.01) ? Number(expectedExit).toFixed(2) : Number(expectedExit).toFixed(6);
    if(remainingMs <= 0){
      clearInterval(tr._uiInterval);
    }
  }, 500);
}
function removeOpenTradeUI(id){
  const el = document.getElementById('open_' + id);
  if(el) el.remove();
}
function markTradeClosedUI(tr, isWin, exitPrice){
  const el = document.getElementById('open_' + tr.id);
  if(!el) return;
  el.classList.add('trade-closed');
  const entryEl = el.querySelector('.entryPrice');
  const exitEl = el.querySelector('.exitPrice');
  const countdown = el.querySelector('.countdown');
  if(entryEl) entryEl.textContent = Number(tr.entryPrice).toFixed(2);
  if(exitEl) exitEl.textContent = Number(exitPrice).toFixed(2);
  if(countdown) countdown.textContent = isWin ? 'MENANG' : 'KALAH';
  const left = el.querySelector('.left');
  const res = document.createElement('div');
  res.style.marginTop = '6px';
  res.innerHTML = `<div style="font-weight:800;color:${isWin? 'var(--green)':'var(--red)'}">${isWin ? 'Win' : 'Lose'}</div>`;
  left.appendChild(res);
  setTimeout(()=> { try{ el.remove(); } catch(e){} }, 6000);
}

/* ===== trade creation & resolution (tie => loss) ===== */
function executeTrade(side){
  const bet = Number(betAmountInput.value || 0);
  if(!bet || bet < 15000) return alert('Minimal transaksi Rp 15.000');
  const m = markets[currentMarketId];
  if(m && m.locked){
    alert('Market tutup â€” perdagangan gagal.');
    if(currentUser && accountMode === 'live'){
      db.collection('users').doc(currentUser.uid).collection('history').add({
        type: 'trade_attempt', side, market: currentMarketId, amount: bet, result: 'market_tutup', createdAt: firebase.firestore.FieldValue.serverTimestamp()
      }).catch(()=>{});
    }
    return;
  }
  const activeBal = getActiveBalance();
  if(bet > activeBal) return alert('Saldo tidak cukup');
  if(!currentUser) return alert('Belum login');

  // entry price uses latest available
  const entryPrice = getMarketLivePrice(currentMarketId);
  const dur = parseDurationToSeconds(durationInput.value || '00:01:00');
  const expiryTs = Date.now() + (dur*1000);
  const payoutPercent = (m && m.payoutPercent) ? Number(m.payoutPercent) : 70;
  const tradeId = 't_' + Date.now() + '_' + Math.floor(Math.random()*9999);
  const tr = { id: tradeId, uid: currentUser ? currentUser.uid : null, market: currentMarketId, side, amount: bet, entryPrice, expiryTs, payoutPercent };

  if(accountMode === 'demo'){
    demoBalance = Math.max(0, demoBalance - bet);
    tr._mode = 'demo';
    openTrades.push(tr);
    addOpenTradeUI(tr);
    scheduleDemoResolution(tr);
    saveDemoOpenTrades();
    updateBalanceDisplays();
  } else {
    db.runTransaction(async (t)=>{
      const uref = db.collection('users').doc(currentUser.uid);
      const ud = await t.get(uref);
      if(!ud.exists) throw 'no user';
      const prev = (ud.data().balance) ? Number(ud.data().balance) : 0;
      if(prev < bet) throw 'insufficient';
      const newBal = prev - bet;
      t.set(uref, { balance: newBal, updatedAt: firebase.firestore.FieldValue.serverTimestamp() }, { merge:true });
      const optRef = db.collection('users').doc(currentUser.uid).collection('openTrades').doc(tradeId);
      t.set(optRef, { ...tr, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
    }).then(()=>{
      tr._mode = 'live';
      openTrades.push(tr);
      addOpenTradeUI(tr);
      scheduleLiveResolution(tr);
      balance = Math.max(0, balance - bet);
      updateBalanceDisplays();
    }).catch(err=>{
      console.error(err);
      alert('Gagal membuka trade: ' + (err === 'insufficient' ? 'saldo tidak cukup' : err));
      return;
    });
  }
  updateSummary();
}

/* Demo resolution */
async function resolveDemoTrade(tr){
  const found = openTrades.find(x=>x.id === tr.id && x._mode === 'demo');
  if(!found) return;
  const exitPrice = await fetchLatestPriceForMarket(tr.market);
  const isBuy = (tr.side.toLowerCase() === 'naik' || tr.side.toLowerCase() === 'call');
  let isWin = false;
  if(exitPrice > tr.entryPrice) isWin = isBuy;
  else if(exitPrice < tr.entryPrice) isWin = !isBuy;
  else isWin = false;
  const payoutPercent = tr.payoutPercent || 70;
  const bet = Number(tr.amount || 0);
  const profit = Math.round((payoutPercent/100) * bet);

  if(isWin){
    demoBalance = demoBalance + bet + profit;
    const text = `Menang +Rp ${profit.toLocaleString('id-ID')} (plus pengembalian stake Rp ${bet.toLocaleString('id-ID')})`;
    const li = document.createElement('div'); li.className='history-item';
    li.innerHTML = `<div>${new Date().toLocaleTimeString()} â€” ${tr.market} â€” ${tr.side}</div><div style="color:#22c55e">${text}</div>`;
    listTrades.prepend(li); sideTradeList.prepend(li.cloneNode(true));
    markTradeClosedUI(tr, true, exitPrice);
  } else {
    const text = `Kalah -Rp ${bet.toLocaleString('id-ID')}`;
    const li = document.createElement('div'); li.className='history-item';
    li.innerHTML = `<div>${new Date().toLocaleTimeString()} â€” ${tr.market} â€” ${tr.side}</div><div style="color:#fb7185">${text}</div>`;
    listTrades.prepend(li); sideTradeList.prepend(li.cloneNode(true));
    markTradeClosedUI(tr, false, exitPrice);
  }

  removeDemoOpenTradeById(tr.id);
  if(demoTradeTimers[tr.id]){ clearTimeout(demoTradeTimers[tr.id]); delete demoTradeTimers[tr.id]; }
  updateBalanceDisplays();
}

/* Live resolution */
async function resolveLiveTrade(tradeId){
  if(!currentUser) return;
  const docRef = db.collection('users').doc(currentUser.uid).collection('openTrades').doc(tradeId);
  try{
    const doc = await docRef.get();
    if(!doc.exists) return;
    const tr = { id: doc.id, ...doc.data() };
    const exitPrice = await fetchLatestPriceForMarket(tr.market);
    const isBuy = (tr.side.toLowerCase() === 'naik' || tr.side.toLowerCase() === 'call');
    let isWin = false;
    if(exitPrice > tr.entryPrice) isWin = isBuy;
    else if(exitPrice < tr.entryPrice) isWin = !isBuy;
    else isWin = false;
    const payoutPercent = tr.payoutPercent || 70;
    const bet = Number(tr.amount || 0);
    const profit = Math.round((payoutPercent/100) * bet);
    const refundOnWin = bet + profit;

    await db.runTransaction(async (t)=>{
      const uref = db.collection('users').doc(currentUser.uid);
      const udoc = await t.get(uref);
      const prev = (udoc.exists && udoc.data().balance) ? Number(udoc.data().balance) : 0;
      let newBal = prev;
      let text;
      if(isWin){
        newBal = prev + refundOnWin;
        text = `Menang +Rp ${profit.toLocaleString('id-ID')} (plus pengembalian stake Rp ${bet.toLocaleString('id-ID')})`;
      } else {
        newBal = prev;
        text = `Kalah -Rp ${bet.toLocaleString('id-ID')}`;
      }
      t.set(uref, { balance: newBal, updatedAt: firebase.firestore.FieldValue.serverTimestamp() }, { merge:true });
      const histRef = db.collection('users').doc(currentUser.uid).collection('history').doc();
      t.set(histRef, {
        type: 'trade', side: tr.side, entryPrice: tr.entryPrice, exitPrice, amount: bet,
        result: isWin ? 'untung' : 'rugi', text, createdAt: firebase.firestore.FieldValue.serverTimestamp()
      });
      t.delete(docRef);
    });

    markTradeClosedUI(tr, isWin, exitPrice);
    if(isWin) balance = (balance || 0) + refundOnWin;
    updateBalanceDisplays();
    const li = document.createElement('div'); li.className='history-item';
    li.innerHTML = `<div>${new Date().toLocaleTimeString()} â€” ${tr.market} â€” ${tr.side}</div><div style="color:${isWin?'#22c55e':'#fb7185'}">${isWin ? 'Menang' : 'Kalah'}</div>`;
    listTrades.prepend(li); sideTradeList.prepend(li.cloneNode(true));
    openTrades = openTrades.filter(x=>x.id !== tradeId);
    if(liveTradeTimers[tradeId]){ clearTimeout(liveTradeTimers[tradeId]); delete liveTradeTimers[tradeId]; }
  }catch(e){
    console.error('resolveLiveTrade err', e);
  }
}

/* deposit helpers (unchanged) */
function crc16ccitt(str) {
  let crc = 0xFFFF;
  for (let i = 0; i < str.length; i++) {
    crc ^= (str.charCodeAt(i) << 8);
    for (let j = 0; j < 8; j++) {
      crc = (crc & 0x8000) ? ((crc << 1) ^ 0x1021) : (crc << 1);
      crc &= 0xFFFF;
    }
  }
  return crc.toString(16).toUpperCase().padStart(4, '0');
}
function padLen(n){ return String(n).padStart(2,'0'); }
function insertAmountTag(payload630, amountStr) {
  const amountField = '54' + padLen(amountStr.length) + amountStr;
  const idx5303 = payload630.indexOf('5303');
  if (idx5303 !== -1) return payload630.slice(0, idx5303) + amountField + payload630.slice(idx5303);
  const idx6304 = payload630.indexOf('6304');
  if (idx6304 !== -1) return payload630.slice(0, idx6304) + amountField + payload630.slice(idx6304);
  return payload630 + amountField;
}
function formatRupiahTwoDecimals(rp){ return rp.toFixed(2); }

let currentRequestDocId = null;
depositPay.addEventListener('click', async ()=>{
  const amt = Number(depositAmount.value || 0);
  const acc = (depositAccount.value || '').trim();
  const method = depositMethod.value || 'Dana';
  if(!amt || amt < 1000) return alert('Minimal Rp 1.000');
  if(!acc) return alert('Masukkan no. rekening');
  const feePercent = amt * 0.008;
  const fixedFee = 850;
  const totalPay = Math.round(amt + feePercent + fixedFee);
  const amountStr = formatRupiahTwoDecimals(totalPay);
  let base = DEFAULT_BASE_PAYLOAD.trim();
  let payloadNoCRC;
  if(base.slice(-8,-4) === '6304') payloadNoCRC = base.slice(0,-8) + '6304';
  else { const idx = base.indexOf('6304'); if(idx !== -1) payloadNoCRC = base.slice(0, idx+4); else payloadNoCRC = base + '6304'; }
  const withAmount630 = insertAmountTag(payloadNoCRC, amountStr);
  const crc = crc16ccitt(withAmount630);
  const finalPayload = withAmount630 + crc;
  depositQRWrap.style.display = 'block';
  qrcodeDyn.innerHTML = '';
  new QRCode(qrcodeDyn, { text: finalPayload, width:200, height:200 });
  finalPayloadEl.textContent = finalPayload;
  try{
    const req = {
      uid: currentUser ? currentUser.uid : null,
      type: 'deposit',
      nominal: amt,
      totalPay,
      method,
      account: acc,
      payload: finalPayload,
      status: 'pending',
      paidByUser: false,
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
    };
    const docRef = await db.collection('requests').add(req);
    currentRequestDocId = docRef.id;
    alert('Request deposit dibuat. Klik "Sudah Bayar" setelah melakukan transfer.');
    renderMiniRequests();
  }catch(e){
    console.error(e); alert('Gagal membuat request.');
  }
});
markPaidBtn.addEventListener('click', async ()=>{
  if(!currentRequestDocId) return alert('Tidak ada request aktif');
  try{
    await db.collection('requests').doc(currentRequestDocId).update({ paidByUser:true, status:'paidByUser', paidAt: firebase.firestore.FieldValue.serverTimestamp() });
    alert('Ditandai sudah bayar. Tunggu konfirmasi admin.');
    renderMiniRequests();
  }catch(e){ console.error(e); alert('Gagal mark paid'); }
});
depositClose.addEventListener('click', ()=> depositModal.style.display = 'none');
depositCancel.addEventListener('click', ()=> depositModal.style.display = 'none');

function openDepositPage(){
  if(accountMode === 'demo'){
    demoBalance = 100000 + Math.floor(Math.random()*50000);
    updateBalanceDisplays();
    alert('Saldo demo diperbarui: Rp ' + Number(demoBalance).toLocaleString('id-ID'));
    return;
  }
  if(DEPOSIT_URL && DEPOSIT_URL.length){
    window.open(DEPOSIT_URL, '_blank');
    return;
  }
  depositModal.style.display = 'flex';
}
openDeposit.addEventListener('click', openDepositPage);
openDeposit2.addEventListener('click', openDepositPage);

/* listen to user (balance, history, requests) */
function listenToUser(uid){
  db.collection('users').doc(uid).onSnapshot(doc=>{
    if(!doc.exists) return;
    const d = doc.data();
    balance = d.balance || 0;
    if(accountMode === 'live') updateBalanceDisplays();
    uidLabel.textContent = uid;
    updateSummary();
  });

  db.collection('users').doc(uid).collection('history').orderBy('createdAt','desc').limit(50).onSnapshot(snap=>{
    listTrades.innerHTML = '';
    sideTradeList.innerHTML = '';
    snap.forEach(s=>{
      const it = s.data();
      const li = document.createElement('div'); li.className='history-item';
      const time = it.createdAt && it.createdAt.toDate ? new Date(it.createdAt.toDate()).toLocaleTimeString() : new Date().toLocaleTimeString();
      li.innerHTML = `<div>${time} â€” ${it.type}</div><div style="color:${it.result==='untung' || it.result==='win'?'#22c55e':'#fb7185'}">${it.text||''}</div>`;
      listTrades.appendChild(li);
      sideTradeList.appendChild(li.cloneNode(true));
    });
  });

  db.collection('requests').where('uid','==',uid).orderBy('createdAt','desc').onSnapshot(snap=>{
    sideRequestsList.innerHTML = '';
    listRequests.innerHTML = '';
    snap.forEach(s=>{
      const r = s.data(); const id = s.id;
      const status = r.status || 'pending';
      const statusCls = status==='confirmed'?'status-confirmed': status==='rejected' ? 'status-rejected' : 'status-pending';
      const div = document.createElement('div'); div.className='history-item';
      div.innerHTML = `<div>${r.type} â€” Rp ${Number(r.nominal||r.amount||0).toLocaleString()}</div><div><span class="status-badge ${statusCls}">${status}</span></div>`;
      sideRequestsList.appendChild(div.cloneNode(true));
      listRequests.appendChild(div);
    });
    if(accountMode === 'demo') sideRequestsList.innerHTML = '';
  });

  subscribeUserOpenTrades(uid);
}

/* admin UI (keperluan edit payout/lock) */
function enableAdminUI(){
  adminInline.style.display = 'block';
  adminPanel.style.display = 'block';
  renderAdminMarkets();
  db.collection('requests').orderBy('createdAt','desc').limit(200).onSnapshot(snap=>{
    requestsList.innerHTML = '';
    snap.forEach(docSnap=>{
      const r = docSnap.data(); const id = docSnap.id;
      const status = r.status || 'pending';
      const item = document.createElement('div'); item.className='req-item';
      item.style.display='flex'; item.style.gap='12px'; item.style.padding='8px 0';
      let actionsHtml = '';
      if(status === 'pending'){
        actionsHtml = `<div><button class="btn-confirm" data-id="${id}">Confirm</button><button class="btn-reject" data-id="${id}">Reject</button></div>`;
      } else {
        actionsHtml = `<div style="color:var(--muted);font-size:13px">Processed</div>`;
      }
      item.innerHTML = `
        <div style="flex:1">
          <div style="font-weight:800">${r.type.toUpperCase()}</div>
          <div style="font-size:13px;color:var(--muted)">uid: ${r.uid} â€¢ Rp ${Number(r.nominal||r.amount||0).toLocaleString()}</div>
          <div style="font-size:12px;margin-top:6px;color:var(--muted)">method: ${r.method||'-'} acct: ${r.account||'-'}</div>
        </div>
        <div style="display:flex;flex-direction:column;gap:6px">
          <div><strong>${status}</strong></div>
          ${actionsHtml}
        </div>
      `;
      requestsList.appendChild(item);
    });
    document.querySelectorAll('.btn-confirm').forEach(b=>{
      b.onclick = ()=> adminConfirmRequest(b.dataset.id);
    });
    document.querySelectorAll('.btn-reject').forEach(b=>{
      b.onclick = ()=> adminRejectRequest(b.dataset.id);
    });
  });
}
async function adminConfirmRequest(requestId){
  if(!currentUser || currentUser.uid !== ADMIN_UID) return alert('Bukan admin');
  const reqRef = db.collection('requests').doc(requestId);
  try{
    await db.runTransaction(async t=>{
      const reqDoc = await t.get(reqRef);
      if(!reqDoc.exists) throw 'not found';
      const r = reqDoc.data();
      if(r.status === 'confirmed') throw 'already';
      const uid = r.uid;
      const userRef = db.collection('users').doc(uid);
      const userDoc = await t.get(userRef);
      const prev = (userDoc.exists && userDoc.data().balance) ? Number(userDoc.data().balance) : 0;
      if(r.type === 'deposit'){
        const add = Number(r.nominal || r.amount || 0);
        const newBal = prev + add;
        t.set(userRef, { balance: newBal, updatedAt: firebase.firestore.FieldValue.serverTimestamp() }, { merge:true });
        t.update(reqRef, { status: 'confirmed', confirmedBy: currentUser.uid, confirmedAt: firebase.firestore.FieldValue.serverTimestamp() });
      } else if(r.type === 'withdraw'){
        const amt = Number(r.nominal || r.amount || 0);
        if(prev < amt){
          t.update(reqRef, { status: 'rejected', rejectedBy: currentUser.uid, rejectedAt: firebase.firestore.FieldValue.serverTimestamp(), rejectedReason: 'insufficient' });
          throw 'insufficient';
        } else {
          const newBal = prev - amt;
          t.set(userRef, { balance: newBal, updatedAt: firebase.firestore.FieldValue.serverTimestamp() }, { merge:true });
          t.update(reqRef, { status: 'confirmed', confirmedBy: currentUser.uid, confirmedAt: firebase.firestore.FieldValue.serverTimestamp() });
        }
      } else {
        t.update(reqRef, { status: 'confirmed', confirmedBy: currentUser.uid, confirmedAt: firebase.firestore.FieldValue.serverTimestamp() });
      }
    });
    alert('Request dikonfirmasi.');
  }catch(e){
    console.error(e); alert('Gagal konfirmasi: ' + e);
  }
}
async function adminRejectRequest(requestId){
  if(!currentUser || currentUser.uid !== ADMIN_UID) return alert('Bukan admin');
  try{
    await db.collection('requests').doc(requestId).update({ status:'rejected', rejectedBy: currentUser.uid, rejectedAt: firebase.firestore.FieldValue.serverTimestamp() });
    alert('Request ditolak.');
  }catch(e){ console.error(e); alert('Gagal menolak'); }
}

/* admin markets UI: allow overriding payout/volatility/lock in Firestore by market key
   (this part is optional persistence â€” if admin edits, we store override doc in 'markets' keyed by marketKey)
*/
function renderAdminMarkets(){
  adminMarketsContainer.innerHTML = '';
  Object.keys(markets).forEach(id=>{
    const m = markets[id];
    const row = document.createElement('div'); row.className='market-edit';
    row.innerHTML = `
      <div style="min-width:110px;font-weight:700">${m.symbol||id}</div>
      <input type="number" step="0.0001" placeholder="vol" value="${m.volatilityFraction||0.002}" data-id="${id}" class="vol-input">
      <input type="number" step="1" placeholder="payout" value="${m.payoutPercent||70}" data-id="${id}" class="pay-input">
      <button class="save-btn" data-id="${id}">Save</button>
      <button class="lock-btn" data-id="${id}" style="padding:6px 10px;border-radius:8px;margin-left:6px">${m.locked ? 'Unlock' : 'Lock'}</button>
      <div style="font-size:12px;color:var(--muted);margin-left:10px">${m.cgId ? 'cg:'+m.cgId : 'no cg mapping'}</div>
    `;
    adminMarketsContainer.appendChild(row);
  });
  adminMarketsContainer.querySelectorAll('.save-btn').forEach(btn=>{
    btn.onclick = async ()=>{
      const id = btn.dataset.id;
      const vol = adminMarketsContainer.querySelector(`.vol-input[data-id="${id}"]`).value;
      const pay = adminMarketsContainer.querySelector(`.pay-input[data-id="${id}"]`).value;
      // save override to Firestore under collection 'markets' doc id = encodeURIComponent(id)
      try{
        await db.collection('markets').doc(encodeURIComponent(id)).set({ volatilityFraction: Number(vol), payoutPercent: Number(pay) }, { merge:true });
        // also update local memory
        if(markets[id]) { markets[id].volatilityFraction = Number(vol); markets[id].payoutPercent = Number(pay); updateMarketUI(); }
        alert('Saved (override stored)');
      }catch(e){ console.error(e); alert('Save failed'); }
    };
  });
  adminMarketsContainer.querySelectorAll('.lock-btn').forEach(btn=>{
    btn.onclick = async ()=>{
      const id = btn.dataset.id;
      const m = markets[id] || {};
      const newLocked = !m.locked;
      try{
        await db.collection('markets').doc(encodeURIComponent(id)).set({ locked: newLocked }, { merge:true });
        if(markets[id]) { markets[id].locked = newLocked; updateMarketUI(); }
        alert((newLocked ? 'Market dikunci' : 'Market dibuka') + `: ${id}`);
      }catch(e){ console.error(e); alert('Gagal update lock'); }
    };
  });
}

/* ===== init app & auth ===== */
let balance = 0;
auth.onAuthStateChanged(async (user)=>{
  if(user){
    currentUser = user;
    uidLabel.innerText = user.uid;
    const uref = db.collection('users').doc(user.uid);
    const docu = await uref.get();
    if(!docu.exists){
      await uref.set({ balance: 0, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
    }
    listenToUser(user.uid);
    isAdmin = (user.uid === ADMIN_UID);
    if(isAdmin){ enableAdminUI(); }
    // start: fetch top10 markets from CoinGecko + poll prices
    await fetchTop10CoinGeckoMarkets();
    pollCoinGeckoPrices();
    // load overrides from Firestore 'markets' collection (if any)
    db.collection('markets').get().then(snap=>{
      snap.forEach(doc=>{
        const id = decodeURIComponent(doc.id);
        if(markets[id]){
          const od = doc.data();
          if(typeof od.volatilityFraction !== 'undefined') markets[id].volatilityFraction = od.volatilityFraction;
          if(typeof od.payoutPercent !== 'undefined') markets[id].payoutPercent = od.payoutPercent;
          if(typeof od.locked !== 'undefined') markets[id].locked = od.locked;
        }
      });
      updateMarketUI();
      renderAdminMarkets();
    }).catch(()=>{});
    if(accountMode === 'demo') loadDemoOpenTrades();
  } else {
    auth.signInAnonymously().catch(e=>console.error(e));
  }
});

/* UI bindings */
symbolSelectTop.addEventListener('change', ()=>{
  currentMarketId = symbolSelectTop.value;
  updateMarketUI();
  generateInitialChartData();
  startChartAnimation();
  renderAdminMarkets();
});
betAmountInput.addEventListener('input', updateSummary);
durationInput.addEventListener('input', ()=>{ document.getElementById('currDur').textContent = parseDurationToSeconds(durationInput.value); });

btnUp.addEventListener('click', ()=> executeTrade('Naik'));
btnDown.addEventListener('click', ()=> executeTrade('Turun'));

tabOpenTrades.addEventListener('click', ()=>{ tabOpenTrades.classList.add('active'); tabTradeHistory.classList.remove('active'); tabRequests.classList.remove('active'); listOpenTrades.style.display='block'; listTrades.style.display='none'; listRequests.style.display='none'; });
tabTradeHistory.addEventListener('click', ()=>{ tabOpenTrades.classList.remove('active'); tabTradeHistory.classList.add('active'); tabRequests.classList.remove('active'); listOpenTrades.style.display='none'; listTrades.style.display='block'; listRequests.style.display='none'; });
tabRequests.addEventListener('click', ()=>{ tabOpenTrades.classList.remove('active'); tabTradeHistory.classList.remove('active'); tabRequests.classList.add('active'); listOpenTrades.style.display='none'; listTrades.style.display='none'; listRequests.style.display='block'; });

/* mini rendering of requests for side */
function renderMiniRequests(){
  if(!currentUser) return;
  if(accountMode === 'demo'){
    document.getElementById('miniRequests').innerHTML = '<div style="color:var(--muted)">Demo: tidak ada request</div>';
    return;
  }
  db.collection('requests').where('uid','==', currentUser.uid).orderBy('createdAt','desc').limit(6).get().then(snap=>{
    document.getElementById('miniRequests').innerHTML = '';
    snap.forEach(s=>{
      const r = s.data();
      const div = document.createElement('div'); div.style.padding='6px 0'; div.innerHTML = `${r.type} â€¢ Rp ${Number(r.nominal||0).toLocaleString()} â€¢ ${r.status||'pending'}`;
      document.getElementById('miniRequests').appendChild(div);
    });
  }).catch(()=>{});
}

/* clock */
setInterval(()=>{ const d = new Date(); document.getElementById('clock').innerText = d.toLocaleTimeString(); },1000);

/* initial UI */
updateSummary();
resizeCanvas();
generateInitialChartData();
startChartAnimation();

// start polling even before auth (in case markets fetched)
pollCoinGeckoPrices();

</script>
</body>
</html>
